---
title: "Antibiotic resistance"
output: html_document
knit: (function(inputFile, encoding,...) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "~/Dropbox/antibioticResistance/output") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE}
library(ggplot2)
library(tidyverse)
library(ensurer)
#devtools::install_github("terminological/standard-print-output")
#library(standardPrintOutput)
devtools::load_all("~/Git/standard-print-output/")

theme_set(standardPrintOutput::defaultFigureLayout())
# devtools::install_github("terminological/tidy-info-stats")
devtools::load_all("~/Git/tidy-info-stats/")
# library(tidyinfostats)


# rm(list = ls(all.names = TRUE))
devtools::load_all("~/Git/etl-analysis/r-packages/omop-utils/")
source("./antibioticResistanceSetup.R")
```

Find test results for sensitivity or resistance.

These are tests whose results are concepts that are "Resistant" or "Sensistive" (but not "Methicillin resistant staph aureus")

* No matching results - relates to Flucloxacillin as Fluclox Susceptability missing from OMOP database as not licensed in US
* Sample from measurement source value
* Antibiotic name from concept string
* Summary counts of sensisitivity and resistance on per antibiotic basis and confidence intervals estimated from binomials

# Correlate urine culture sensitivities with record data

* predict resistance against given AbX using info available at point of diagnosis
* known sample type, known planned antibiotics.
* Lets focus on single sample - such as Urine & common Abx such as Nitrofurantoin and Trimethoprim

Steps:

* identify cohort of sensitivity results (exclude people with multiple samples at same datetime) and event datetime
* We exclude multiple species at this point as we cannot know which species sensitivities are for.
* TODO: an alternative strategy for multiple species is to take worst case sensitivities for samples with duplicate entries.
* generate a sample id for each result
* identify nlp codes from record earlier than event datetime as predictorVariables
* calculate tfidf from nlp_codes


```{r}
# Get the sensitivity results in the omop database

dbSensitivityResults = omop$measurement %>% 
  semi_join(resistanceOutcome$result, by=c("value_as_concept_id"="concept_id")) %>% 
  filter(measurement_source_value %like% "%UCUL") %>% omop$getConceptNames() %>%
  mutate(
    antibiotic = ifelse(measurement_concept_name=="No matching concept","Flucloxacillin", replace(measurement_concept_name, " [Susceptibility]",""))
  ) %>% filter(
    antibiotic %in% c("Trimethoprim","Nitrofurantoin")
  ) %>% 
  group_by(person_id,measurement_datetime,antibiotic) %>% mutate(uniq = n()) %>% filter(uniq == 1) %>% select(-uniq) %>%
  ungroup() %>% compute()

# generate a summary table
dbSensitivityResults  %>% group_by(antibiotic, value_as_concept_name) %>% summarise(
  count = n(),
  patients = n_distinct(person_id)
) %>% ungroup() %>% arrange(antibiotic,value_as_concept_name)  %>% group_by(antibiotic) %>% saveTable("~/Dropbox/antibioticResistance/utiSampleCounts")

# colnames(dbSensitivityResults)

# grab just the outcome data we are interested in - 2 outcome classes with 2 possible outcomes
outcomeCohort = dbSensitivityResults %>% select(
  person_id, 
  antibiotic, 
  outcome_type=measurement_concept_id, 
  sensitivity=value_as_concept_name, 
  outcome_value=value_as_concept_id, 
  event_datetime=measurement_datetime 
)  %>% createSequentialIdentifier(vars(person_id,event_datetime), sample_id) %>% 
  compute(index=c("person_id","event_datetime","sample_id"))

# TODO: consider getting the first (?last) event for each patient
```

```{r}

# colnames(omop$note)
# colnames(omop$note_nlp)

# get predictors...
predictorVariables = outcomeCohort %>% 
  select(person_id, event_datetime, sample_id) %>% 
  inner_join(omop$note, by="person_id") %>% 
  filter(note_datetime < event_datetime) %>% 
  inner_join(omop$note_nlp, by="note_id") %>%
  compute(index=c("sample_id"))

# This summarises the content of the predictor variables, but needs work on summariseTopN to allow layers of nesting
# predictorSummary = predictorVariables %>% group_by(note_nlp_concept_id) %>% summarise(count = n()) %>% omop$getConceptNames() %>% collect()
# predictorSummary %>% group_by(note_nlp_concept_name) %>% summariseTopN(n=20, sortVar=desc(count), count = sum(count))

predictorTfidf = predictorVariables %>% group_by(sample_id) %>% 
  tidyinfostats::calculateTfidf(vars(note_nlp_concept_id)) %>% compute(index=c("sample_id"))
```

```{r}
# predictorVariables %>% count()

predictorVariablesExpanded = predictorVariables %>% 
  group_by(sample_id) %>%
  omop$expandAncestorConcepts(note_nlp_concept_id)

predictorTfidfExpanded = predictorVariablesExpanded %>% group_by(sample_id) %>% 
  tidyinfostats::calculateTfidf(vars(note_nlp_concept_id)) %>% compute(index=c("sample_id"))


# TODO: expand hierarchy
# TODO: include other sources of info (e.g. blood tests, procedures, diagnoses)
```

# Use outcomes and predictors to generate a mutual information score

```{r}
antibioticSet = outcomeCohort %>% inner_join(predictorTfidf, by="sample_id") %>% arrange(sample_id) %>% compute() %>% ungroup()
antibioticSetExpanded = outcomeCohort %>% inner_join(predictorTfidfExpanded, by="sample_id") %>% arrange(sample_id) %>% compute() %>% ungroup()


```

```{r}
# antibioticMI = antibioticSet %>% group_by(antibiotic,note_nlp_concept_id) %>% calculateDiscreteContinuousMI(vars(sensitivity), norm_okapi_bm25)
#tmp = antibioticSet %>% expectOnePerSample(vars(sensitivity), vars(person_id)) %>% collect()
#antibioticMIAbs = antibioticSet %>% group_by(antibiotic,note_nlp_concept_id) %>% calculateDiscreteAbsentValuesMI(vars(sensitivity), vars(person_id))

tmp = antibioticSet %>% group_by(antibiotic,note_nlp_concept_id) %>% calculateDiscreteAbsentValuesMI(
  discreteVars = vars(sensitivity), 
  sampleVars = vars(sample_id)) %>%
	  rename(I_given_abs = I) %>% mutate(tmp_join=1) %>% compute() %>% omop$getConceptNames() %>% collect()

antibioticMI = antibioticSet %>% group_by(antibiotic,note_nlp_concept_id) %>% calculateDiscreteContinuousMI( 
  discreteVars = vars(sensitivity),
  continuousVar = norm_okapi_bm25)

antibioticMI = antibioticSet %>% group_by(antibiotic,note_nlp_concept_id) %>% adjustMIForAbsentValues( 
  discreteVars = vars(sensitivity), 
  sampleVars = vars(sample_id),
  mutualInformationFn = calculateDiscreteContinuousMI, 
  continuousVar = norm_okapi_bm25)

antibioticMIResult = antibioticMI %>% compute() %>% omop$getConceptNames() %>% collect()

antibioticMIResult %>% group_by(antibiotic,note_nlp_concept_name) %>% summariseTopN(n=10, sortVar=desc(I), I = max(I), N=sum(N)) %>% ungroup() %>%
  saveTable("~/Dropbox/antibioticResistance/mostInformation")


antibioticMIExpanded = antibioticSetExpanded %>% group_by(antibiotic,note_nlp_concept_id) %>% calculateDiscreteContinuousMI( 
  discreteVars = vars(sensitivity),
  continuousVar = norm_okapi_bm25)

antibioticMIExpanded = antibioticSetExpanded %>% group_by(antibiotic,note_nlp_concept_id) %>% adjustMIForAbsentValues( 
  discreteVars = vars(sensitivity), 
  sampleVars = vars(sample_id),
  mutualInformationFn = calculateDiscreteContinuousMI, 
  continuousVar = norm_okapi_bm25)

antibioticMIResultExpanded = antibioticMIExpanded %>% compute() %>% omop$getConceptNames() %>% collect()

antibioticMIResultExpanded %>% group_by(antibiotic,note_nlp_concept_name) %>% summariseTopN(n=10, sortVar=desc(I), I = max(I), N=sum(N_obs)) %>% ungroup() %>%
  saveTable("~/Dropbox/antibioticResistance/mostInformationExpanded")
# TODO: this would be better as a groupwise summariseTopN
# TODO: adjust MI for absent values needs testing
# TODO: debug MI for Absent values
#debugSubset2 = antibioticSet %>% filter(note_nlp_concept_id %in% c(4053015) & antibiotic=="Trimethoprim")  %>% collect()

# TODO: investigate effect of expanded hierarchy
# TODO: cooccuring codes

# https://cran.r-project.org/web/packages/ensurer/vignettes/ensurer.html

```

# generate machine learning matrix

```{r}
# devtools::load_all("~/Git/tidy-info-stats")
# https://rpubs.com/kelsimp/10992

trimethoprimData = antibioticSet %>% filter(antibiotic=="Trimethoprim")

## TODO: refactor this to a single function call with matrix and features
## test ensure samples are correctly ordered.

trimethoprimTrainingSet = trimethoprimData %>%
  omop$getConceptNames() %>% compute() %>% collectAsTrainingSet(
  sample_id, sensitivity, note_nlp_concept_id, norm_okapi_bm25, featureNameVar=note_nlp_concept_name)


saveRDS(trimethoprimTrainingSet, file = "~/Dropbox/antibioticResistance/data/trimethoprimTrainingSet.rds")

expect_equal(nrow(trimethoprimTrainingSet$matrix),length(trimethoprimTrainingSet$outcome))
```

```{r}
trimethoprimDataExpanded = antibioticSetExpanded %>% filter(antibiotic=="Trimethoprim")

trimethoprimTrainingSetExpanded = trimethoprimDataExpanded %>%
  omop$getConceptNames() %>% compute() %>% collectAsTrainingSet(
  sample_id, sensitivity, note_nlp_concept_id, norm_okapi_bm25, featureNameVar=note_nlp_concept_name)

saveRDS(trimethoprimTrainingSetExpanded, file = "~/Dropbox/antibioticResistance/data/trimethoprimTrainingSetExpanded.rds")

# Save an object to a file

# Restore the object
# readRDS(file = "~/Dropbox/antibioticResistance/data/trimethoprimMatrix.rds")
# readRDS(file = "~/Dropbox/antibioticResistance/data/trimethoprimOutcome.rds")

```
## family of cost weighted models

* TODO: adjust cost wieghts for a range of outcomes
* TODO: calculate models
* TODO: compare variable importance from log regression to MI based importance
* TODO: generate roc curves for models
* TODO: optimise cut-off for maximum value

## improving input data

* DONE: Data set including hierarchical expansion of TFIDF
* TODO: MI Cooccurence (within patient (aka sample)? within outcome?)
* TODO: adjustment of MI between feature and outcome - clustering?
* TODO: compare variable importance from log regression to MI based importance
* TODO: cost weighting of feature MI
* TODO: Dimensionality reduction? 

```{r}

for (ts in list(trimethoprimTrainingSet,trimethoprimTrainingSetExpanded)) {

  ts = tidyIris() %>% mutate(
    outcome = ifelse(as.character(outcome)=="setosa","Resistant","Sensitive")
  ) %>% collectAsTrainingSet(sample,outcome,feature,value)
  
  samples = length(ts$outcome)
  train = sample(1:samples,floor(samples*0.8))
  
  tmpSm = tidyinfostats::sparseMatrixToSparseMCsr(ts$matrix)

  xTrain = tmpSm[train,]
  xTest = tmpSm[-train,]
  yTrain = ts$outcome[train]
  yTest = ts$outcome[-train]

  wi = c(Resistant=2.5,Sensitive=1)
  
  # Re-train best model with best cost value.
  m=LiblineaR::LiblineaR(data=xTrain,target=yTrain,type=0,cost=1,verbose=FALSE,wi=wi,bias=0)

  # Scale the test data
  # s2=xTest # scale(xTest,attr(s,"scaled:center"),attr(s,"scaled:scale"))
  # varImp = m$W
  # names(varImp) <- colnames(trimethoprimSparseMatrix)

  varImp = tibble(
    name = ts$colLabels,
    weight = m$W[1:length(ts$colLabels)]
  ) %>% mutate(importance = abs(weight))

  # Make prediction
  #pr=FALSE
  #if(bestType==0 || bestType==6 || bestType==7) pr=TRUE

  p=predict(m,xTest,proba=TRUE,decisionValues=TRUE)

  # Display confusion matrix
  predResult = data.frame(p$probabilities) %>% mutate(actual = yTest, pred = p$predictions)

  ggplot(predResult, aes(x=Sensitive,colour=actual))+geom_density()

  predResult %>% group_by(actual,pred) %>% count()

  res=table(p$predictions,yTest)
  print(res)
}

```

```{r}
for (ts in c(trimethoprimTrainingSet,trimethoprimTrainingSetExpanded)) {
  
  #ts = tidyIris() %>% mutate(
  #  outcome = ifelse(as.character(outcome)=="setosa","Resistant","Sensitive")
  #) %>% collectAsTrainingSet(sample,outcome,feature,value)

  samples = length(ts$outcome)
  train = sample(1:samples,floor(samples*0.8))
  
  xTrain = ts$matrix[train,]
  xTest = ts$matrix[-train,]
  yTrain = ts$outcome[train]
  yTest = ts$outcome[-train]

  wi = c(Resistant=2,Sensitive=1)

  #Malley et al. (2012).
  rg = ranger::ranger(x=xTrain, y=yTrain, importance="impurity", probability = TRUE, class.weights = wi)
  rg$variable.importance
  
  rg.predict = predict(rg,data=xTest)
  
  predResult = data.frame(rg.predict$predictions) %>% mutate(actual = yTest, pred = as.factor(ifelse(Sensitive>0.5,"Sensitive","Resistant")))
  
  ggplot(predResult, aes(x=Sensitive,colour=actual))+geom_density()
}

```

```{r}

xTest = trimethoprimSparseMatrix[-train,]
yTest = trimethoprimOutcome[-train]



```


