---
title: "mutual-information-estimation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mutual-information-estimation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(tidyinfostats)
```


```{r}
# TODO: Add comment
# 
# Author: Rob Challen
###############################################################################

library(infotheo)
library(tidyverse)
library(ggplot2)

data(USArrests)
dat<-discretize(USArrests)
#computes the MIM (mutual information matrix)
I <- mutinformation(dat,method= "emp")
I2<- mutinformation(dat[,1],dat[,2])


tidydat = dat %>% 
		mutate(state = rownames(USArrests)) 
#%>% 
#		pivot_longer(-state, names_to = "crime", values_to = "level")

ptidy = tidydat %>% probabilitiesFromGroups(Murder,Assault)
t1 = ptidy %>% calculateBinaryMI()
t2 = ptidy %>% calculateMultiClassMI() # should be the same as I2

t1 = t1 %>% mutate(
		checkMi = miFromCounts(f_xy,f_x,f_y,N),
		checkNpmi = pmiFromCounts(f_xy,f_x,f_y,N),
		checkPmi = npmiFromCounts(f_xy,f_x,f_y,N)
)

tidydat2 = dat %>% 
		mutate(state = rownames(USArrests)) %>%
		pivot_longer(-state, names_to = "variable", values_to = "level")

# get a tidy version of the dat data - i.e. 
tidydat3 = tidydat2 %>% rename(variable1=variable, level1=level) %>% inner_join(
		tidydat2 %>% rename(variable2=variable, level2=level), by="state")

t3 = tidydat3 %>% group_by(variable1,variable2) %>% probabilitiesFromGroups(level1,level2) %>% calculateMultiClassMI()
t3 %>% pivot_wider(names_from=variable2, values_from=mi) # should be the same as I



collision = tibble(test=rep("K",25),outcome=rep("low",25),value=rnorm(25,1,1))
contMI = tibble(test=rep("haemoglobin",75),outcome=rep("good",75),value=rnorm(75,12,3)) %>% bind_rows(
				tibble(test=rep("haemoglobin",75),outcome=rep("bad",75),value=rnorm(75,8,4))) %>% bind_rows(
				tibble(test=rep("K",50),outcome=rep("ok",50),value=rnorm(50,3,2))) %>% bind_rows(
				tibble(test=rep("K",25),outcome=rep("high",25),value=rnorm(25,8,5))) %>% bind_rows(
				collision) %>% bind_rows(collision)

ggplot(contMI, aes(fill=outcome, x=value))+geom_histogram(position="dodge")+facet_grid(cols=vars(test))

# verify collisions
View(contMI %>% filter(outcome=="low" & test=="K") %>% arrange(value))


binaryOC = contMI %>% filter(test=="haemoglobin") %>% select(outcome,value) %>% mutate(outcome = outcome=="good") %>% discretize(nbins=20)
mutinformation(
		binaryOC[,1],binaryOC[,2]
)

generateDataSet = function(mus, sigmas, counts) {
	outcomes = seq(1,length(mus))
	labels=paste0("\U003BC=",mus,"; \u03C3=",sigmas,"; n=",counts)
	points = length(mus)
	out = NULL
	for (i in seq(1,points)) {
		tmp = tibble(
				#test=rep(name,counts[i]),
				outcome=rep(outcomes[i],counts[i]),
				label=rep(labels[i],counts[i]),
				value=rnorm(counts[i],mus[i],sigmas[i])
		)
		if (!is.null(out)) {
			out = out %>% bind_rows(tmp)
		} else {
			out = tmp
		}
	}
	return(out)
}

theoreticalMI = function(mus, sigmas, counts) {
	px = counts/sum(counts)
	pxy = function(y) sapply(y, function(y) px*dnorm(y,mus,sigmas)) # i.e. p(x) * p(y given x)
	py = function(y) sapply(y, function(y) sum(pxy(y))) # this gives us over all x
	Iix = function(y) sapply(y, function(y) sum(ifelse(py(y)==0|pxy(y)==0,0,pxy(y)*log(pxy(y)/(px*py(y))))))
	return(integrate(Iix,min(mus-10*sigmas),max(mus+10*sigmas))$value)
}

plotTheoreticalMI = function(mus, sigmas, counts) {
	d = data.frame(y=seq(min(mus-3*sigmas),max(mus+3*sigmas),length.out=10000))
	d = d %>% tidyr::crossing(data.frame(x=paste0("\U003BC=",mus,"; \u03C3=",sigmas,"; n=",counts)))
	d = d %>% mutate(
					px = counts[x]/sum(counts),
					pxy = px*dnorm(y,mus[x],sigmas[x])
			) %>% group_by(y) %>% mutate(
					py = sum(pxy)
			) 
	d = d %>% group_by(x) %>% mutate(
					Iix = pxy*log(pxy/(px*py)),
					dy = (y-lag(y))
			) %>% group_by(x) %>% arrange(y) %>% mutate(
					trap = (Iix+lag(Iix,0))*dy/2
			) 
	I = d %>% ungroup() %>% summarise(
			I = sum(trap,na.rm=TRUE)
	) %>% pull(I)
	ggplot(d)+
			geom_line(aes(x=y, y=py),colour="#c0c0c0")+
			geom_line(aes(colour=as.factor(x), x=y, y=pxy))+
			annotate("text", -Inf, Inf, label = paste0("I(X,Y)=",I), hjust = 0, vjust = 1)+
			labs(x="y",y="p(x\u2229y)",colour="x")
}

mus = c(10,10)
sigmas = c(2,2)
counts = c(75,75)
theoreticalMI(mus,sigmas,counts)
theoreticalMI2(mus,sigmas,counts)

mus = c(8,12)
sigmas = c(4,3)
counts = c(500,500)
theoreticalMI(mus,sigmas,counts)
theoreticalMI2(mus,sigmas,counts)

mus = c(1,3,8)
sigmas = c(1,3,5)
counts = c(500,500,250)
theoreticalMI(mus,sigmas,counts)
df = generateDataSet(mus,sigmas,counts)
calculateMultiClassContinuousMI_SG(df, outcome, value,10)
calculateMultiClassContinuousMI_KNN(df, outcome, value,2)

mus = c(1,8)
sigmas = c(1,1)
counts = c(50,50)
theoreticalMI(mus,sigmas,counts)
theoreticalMI2(mus,sigmas,counts)

mus = c(1,3,8)
sigmas = c(1,3,5)
counts = c(500,500,250)
plotTheoreticalMI(mus,sigmas,counts)
df = generateDataSet(mus,sigmas,counts)
ggplot(df)+geom_histogram(aes(fill=as.factor(label),x=value),position="dodge")+
		labs(x="y",y="count",fill="x")
th = theoreticalMI(mus,sigmas,counts)
kout = NULL
for (i in seq(1,100)) {
	# i = 1
	df = generateDataSet(mus,sigmas,counts)
	k = c(5,7,10,15,20,30,40)
	
	kresult = sapply(k, function(k2) (calculateMultiClassContinuousMI_SG(df, outcome, value, k2) %>% pull(I)))
	kresult = data.frame(
			method = rep("SG",length(k)),
			param = rep("filter width",length(k)),
			test = rep(i,length(k)), 
			value = k, 
			result = kresult,
			theoretical = rep(th,length(k),
					stringsAsFactors=FALSE
			)
	)
	kout = kout %>% bind_rows(kresult)
	
	w = c(1:10)
	
	kresult2 = sapply(w, function(k2) (calculateMultiClassContinuousMI_KNN(df, outcome, value, k2) %>% pull(I)))
	kresult2 = data.frame(
			method = rep("KNN",length(w)),
			param = rep("knn window",length(w)),
			test = rep(i,length(w)), 
			value = w, 
			result = kresult2,
			theoretical = rep(th,length(w)),
			stringsAsFactors=FALSE
	)
	kout = kout %>% bind_rows(kresult2)
	
	# names(kresult) <- k
	binPow = seq(0.1,1,0.1)
	binSize = floor(sum(counts)^binPow)
	nresult = sapply(binSize, function(n2) {
				ref = df %>% select(outcome,value) %>% discretize(n=sum(counts)/n2)
				mutinformation(ref$outcome, ref$value)
			})
	
	nresult = data.frame(
			method = rep("discrete",length(n)),
			param = rep("bins",length(n)),
			test = rep(i,length(n)), 
			value = binSize, 
			result = nresult,
			theoretical = rep(th,length(n)),
			stringsAsFactors=FALSE
	)
	# names(nresult) <- n
	
	kout = kout %>% bind_rows(nresult)
}



kout = kout %>% group_by(method,value) %>% mutate(mean = mean(result),stdev = sd(result))

ggplot(kout)+geom_boxplot(aes(y=result,fill = as.factor(value)))+expand_limits(y=0)+geom_hline(yintercept=th)+facet_grid(cols=vars(method))

ggplot(kout %>% filter(method=="discrete"), aes(x=value))+
		geom_ribbon(aes(ymin=mean-1.96*stdev,ymax=mean+1.96*stdev), fill = "grey70")+
		geom_point(aes(y=mean))+
		geom_line(aes(y=mean))+
		expand_limits(y=0)+
		geom_hline(yintercept=th)
#ggplot(kout %>% filter(method=="KNN"))+geom_boxplot(aes(group=k,y=result,fill = method))+ylim(-2,2)

```